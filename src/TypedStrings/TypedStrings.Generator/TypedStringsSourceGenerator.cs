// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Microsoft.PowerPlatform.TypedStrings.Generator;

[Generator(LanguageNames.CSharp)]
public class TypedStringsSourceGenerator : IIncrementalGenerator
{
    private const string TypedStringAttributeFullName = "Microsoft.PowerPlatform.TypedStrings.TypedStringAttribute";
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(TypedStringsSourceGenerator).Assembly.GetName().Name}"", ""{typeof(TypedStringsSourceGenerator).Assembly.GetName().Version}"")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var recordsToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                TypedStringAttributeFullName,
                predicate: static (s, _) => true, //SyntaxProviderPredicate,
                transform: static (ctx, _) => GetRecordToGenerate(ctx.SemanticModel, ctx.TargetNode)) //GetSemanticTargetForGeneration(ctx))
            .Where(static d => d is not null);

        context.RegisterSourceOutput(recordsToGenerate, static (spc, source) => Execute(source, spc));
    }

    private static RecordToGenerate? GetRecordToGenerate(SemanticModel semanticModel, SyntaxNode recordDeclaration)
    {
        if (semanticModel.GetDeclaredSymbol(recordDeclaration) is not ITypeSymbol { IsRecord: true } recordSymbol)
        {
            return null;
        }

        var isValidMethod = recordSymbol.GetMembers("IsValid")
            .FirstOrDefault(m => m.Kind == SymbolKind.Method && m.IsStatic);

        return new RecordToGenerate(recordSymbol.ContainingNamespace.ToString(), recordSymbol.Name,
            hasIsValidMethod: isValidMethod != null);
    }

    private static void Execute(RecordToGenerate? recordToGenerate, SourceProductionContext context)
    {
        if (recordToGenerate is { } value)
        {
            var result = GenerateTypedStringRecord(value);
            context.AddSource($"{value.Name}.g.cs", result);
        }
    }

    private static string GenerateTypedStringRecord(RecordToGenerate recordToGenerate)
    {
        var isValidSrc = recordToGenerate.HasIsValidMethod
            ? string.Empty // No need to implement IsValid method.
            : """
                // Default implementation of IsValid will simply verify the value is not null.
                // You may implement your own method as long as it's static, and has the same argument signature.
                // You should be able to override the access modifier as needed for your usage.
                private static bool IsValid([NotNullWhen(true)] string? value) => value != null;
                """;

        var source = $$$"""
            // <auto-generated />
            #nullable enable

            using global::System.Diagnostics.CodeAnalysis;
            using global::System.Diagnostics;
            using global::System.Runtime.CompilerServices;

            namespace {{{recordToGenerate.Namespace}}}
            {
                {{{generatedCodeAttribute}}}
                [DebuggerDisplay("{GetDebuggerDisplay}")]
                [SuppressMessage("Design", "CA1036:Override methods on comparable types", Justification = "TODO")] // Remove this suppression and implement using latest recommended performant implementation.
                public partial record {{{recordToGenerate.Name}}} : global::Microsoft.PowerPlatform.TypedStrings.ITypedString<{{{recordToGenerate.Name}}}>
                {
                    public {{{recordToGenerate.Name}}}(string value)
                    {
                        Value = ValidateArgument(value);
                    }

                    public string Value { get; }

                    public static implicit operator string({{{recordToGenerate.Name}}} name) => name.Value;

                    {{{isValidSrc}}}

                    public override string ToString() => Value;

                    public int CompareTo({{{recordToGenerate.Name}}}? other) => Value.CompareTo(other?.Value);

                    private string GetDebuggerDisplay => $"{nameof({{{recordToGenerate.Name}}})} {{ Value = {Value} }}";
            
                    private static string ValidateArgument([NotNull] string? value, [CallerArgumentExpression(nameof(value))] string? argumentName = null)
                    {
                        if (!TryValidate(value, out var validated))
                        {
                            throw new ArgumentException($"Invalid value for a {nameof({{{recordToGenerate.Name}}})}.", argumentName);
                        }
                        return validated;
                    }

                    /// <summary>
                    /// Validates the input value and returns a validated string.
                    /// </summary>
                    private static bool TryValidate([NotNullWhen(true)] string? value, [NotNullWhen(true)] out string? validated)
                    {
                        if (IsValid(value))
                        {
                            global::System.Diagnostics.Debug.Assert(value != null); // Verify `IsValid` is "well behaved".

                            validated = value;
                            return true;
                        }

                        validated = null;
                        return false;
                    }

                    public static {{{recordToGenerate.Name}}} Parse(string value, IFormatProvider? provider)
                    {
                        _ = value ?? throw new ArgumentNullException(nameof(value));

                        if (!TryParse(value, provider, out var parsed))
                        {
                            throw new FormatException($"Invalid string format for a {{{recordToGenerate.Name}}}.");
                        }

                        return parsed;
                    }

                    public static bool TryParse(string? value, IFormatProvider? provider, [NotNullWhen(true)] out {{{recordToGenerate.Name}}}? result)
                    {
                        if (!TryValidate(value, out var validated))
                        {
                            result = default;
                            return false;
                        }

                        result = new(value);
                        return true;
                    }
                }
            }
            """;

        return source;
    }
}
