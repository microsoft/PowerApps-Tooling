// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Microsoft.PowerPlatform.TypedStrings.Generator;

[Generator(LanguageNames.CSharp)]
public class ExampleSourceGenerator : IIncrementalGenerator
{
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(ExampleSourceGenerator).Assembly.GetName().Name}"", ""{typeof(ExampleSourceGenerator).Assembly.GetName().Version}"")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static void (IncrementalGeneratorPostInitializationContext context) =>
        {
            var source = $$"""
                // <auto-generated />
                #nullable enable

                namespace Microsoft.PowerPlatform.TypedStrings.Generator
                {
                    {{generatedCodeAttribute}}
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                    public sealed class TypedStringAttribute : global::System.Attribute
                    {
                    }
                }
                """;

            context.AddSource("_TypedStringAttribute.g.cs", source);
        });


        var recordsToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Microsoft.PowerPlatform.TypedStrings.Generator.TypedStringAttribute",
                predicate: static (s, _) => true, //SyntaxProviderPredicate,
                transform: static (ctx, _) => GetRecordToGenerate(ctx.SemanticModel, ctx.TargetNode)) //GetSemanticTargetForGeneration(ctx))
            .Where(static d => d is not null);

        context.RegisterSourceOutput(recordsToGenerate, static (spc, source) => Execute(source, spc));
    }

    private static RecordToGenerate? GetRecordToGenerate(SemanticModel semanticModel, SyntaxNode recordDeclaration)
    {
        if (semanticModel.GetDeclaredSymbol(recordDeclaration) is not ITypeSymbol { IsRecord: true } recordSymbol)
        {
            return null;
        }

        var isValidMethod = recordSymbol.GetMembers("IsValid")
            .FirstOrDefault(m => m.Kind == SymbolKind.Method && m.IsStatic);

        return new RecordToGenerate(recordSymbol.ContainingNamespace.ToString(), recordSymbol.Name,
            hasIsValidMethod: isValidMethod != null);
    }

    private static void Execute(RecordToGenerate? recordToGenerate, SourceProductionContext context)
    {
        if (recordToGenerate is { } value)
        {
            var result = GenerateTypedStringRecord(value);
            context.AddSource($"{value.Name}.g.cs", result);
        }
    }

    private static string GenerateTypedStringRecord(RecordToGenerate recordToGenerate)
    {
        var isValidSrc = recordToGenerate.HasIsValidMethod
            ? string.Empty // No need to implement IsValid method.
            : """
                // Default implementation of IsValid will simply verify the value is not null.
                // You may implement your own method as long as it's static, and has the same argument signature.
                // You should be able to override the access modifier as needed for your usage.
                private static bool IsValid([NotNullWhen(true)] string? value) => value != null;
                """;

        var source = $$"""
            // <auto-generated />
            #nullable enable

            using global::System.Diagnostics.CodeAnalysis;
            using global::System.Runtime.CompilerServices;
            using global::Microsoft.PowerPlatform.TypedStrings;

            namespace {{recordToGenerate.Namespace}};

            public partial record {{recordToGenerate.Name}} : ITypedString<{{recordToGenerate.Name}}>
            {
                public {{recordToGenerate.Name}}(string value)
                {
                    Value = ValidateArgument(value);
                }

                public string Value { get; }

                public static implicit operator string({{recordToGenerate.Name}} name) => name.Value;

                {{isValidSrc}}

                public override string ToString() => Value;

                private static string ValidateArgument([NotNull] string? value, [CallerArgumentExpression(nameof(value))] string? argumentName = null)
                {
                    if (!TryValidate(value, out var validated))
                    {
                        throw new ArgumentException($"Invalid value for a {nameof({{recordToGenerate.Name}})}.", argumentName);
                    }
                    return validated;
                }

                /// <summary>
                /// Validates the input value and returns a validated string.
                /// </summary>
                private static bool TryValidate([NotNullWhen(true)] string? value, [NotNullWhen(true)] out string? validated)
                {
                    if (IsValid(value))
                    {
                        global::System.Diagnostics.Debug.Assert(value != null); // Verify `IsValid` is "well behaved".

                        validated = value;
                        return true;
                    }

                    validated = null;
                    return false;
                }

                static {{recordToGenerate.Name}} IParsable<{{recordToGenerate.Name}}>.Parse(string s, IFormatProvider? provider)
                {
                    // TODO
                    throw new NotImplementedException();
                }

                static bool IParsable<{{recordToGenerate.Name}}>.TryParse(string? s, IFormatProvider? provider, out {{recordToGenerate.Name}} result)
                {
                    // TODO
                    throw new NotImplementedException();
                }
            }
            """;

        return source;
    }
}
