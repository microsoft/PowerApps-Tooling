// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Microsoft.PowerPlatform.TypedStrings.Generator;

[Generator(LanguageNames.CSharp)]
public class ExampleSourceGenerator : IIncrementalGenerator
{
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(ExampleSourceGenerator).Assembly.GetName().Name}"", ""{typeof(ExampleSourceGenerator).Assembly.GetName().Version}"")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static void (IncrementalGeneratorPostInitializationContext context) =>
        {
            const string filename = "Microsoft.PowerPlatform.TypedStrings.Generated.TypedStringAttribute.g.cs";

            var source = $$"""
                // <auto-generated />
                namespace Microsoft.PowerPlatform.TypedStrings.Generated;

                {{generatedCodeAttribute}}
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                internal sealed class TypedStringAttribute : global::System.Attribute
                {
                }

                """;

            context.AddSource(filename, source);
        });


        var recordsToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Microsoft.PowerPlatform.TypedStrings.Generated.TypedStringAttribute",
                predicate: static (s, _) => true, //SyntaxProviderPredicate,
                transform: static (ctx, _) => GetRecordToGenerate(ctx.SemanticModel, ctx.TargetNode)) //GetSemanticTargetForGeneration(ctx))
            .Where(static d => d is not null);

        context.RegisterSourceOutput(recordsToGenerate, static (spc, source) => Execute(source, spc));
    }

    private static RecordToGenerate? GetRecordToGenerate(SemanticModel semanticModel, SyntaxNode recordDeclaration)
    {
        if (semanticModel.GetDeclaredSymbol(recordDeclaration) is not ITypeSymbol { IsRecord: true } recordSymbol)
        {
            return null;
        }

        return new RecordToGenerate(recordSymbol.ContainingNamespace.ToString(), recordSymbol.Name);
    }

    private static void Execute(RecordToGenerate? recordToGenerate, SourceProductionContext context)
    {
        if (recordToGenerate is { } value)
        {
            var result = GenerateTypedStringRecord(value);
            context.AddSource(value.Name + ".g.cs", result);
        }
    }

    private static string GenerateTypedStringRecord(RecordToGenerate recordToGenerate)
    {
        var source = $$"""
            // <auto-generated />
            #nullable enable

            using System.Diagnostics.CodeAnalysis;
            using System.Runtime.CompilerServices;
            using Microsoft.PowerPlatform.TypedStrings;

            namespace {{recordToGenerate.Namespace}};

            public partial record {{recordToGenerate.Name}} : ITypedString<{{recordToGenerate.Name}}>
            {
                public {{recordToGenerate.Name}}(string value)
                {
                    Value = ValidateArgument(value);
                }

                // IsValid method must be implemented.
                //public static partial bool IsValid([NotNullWhen(true)] string? value);

                public string Value { get; }

                public static implicit operator string({{recordToGenerate.Name}} name) => name.Value;

                public override string ToString() => Value;

                private static string ValidateArgument([NotNull] string? value, [CallerArgumentExpression(nameof(value))] string? argumentName = null)
                {
                    if (!TryValidate(value, out var validated))
                    {
                        throw new ArgumentException($"Invalid value for a {nameof({{recordToGenerate.Name}})}.", argumentName);
                    }
                    return validated;
                }

                /// <summary>
                /// Validates the input value and returns a validated string.
                /// </summary>
                private static bool TryValidate([NotNullWhen(true)] string? value, [NotNullWhen(true)] out string? validated)
                {
                    if (IsValid(value))
                    {
                        validated = value;
                        return true;
                    }

                    validated = null;
                    return false;
                }

                static {{recordToGenerate.Name}} IParsable<{{recordToGenerate.Name}}>.Parse(string s, IFormatProvider? provider)
                {
                    // TODO
                    throw new NotImplementedException();
                }

                static bool IParsable<{{recordToGenerate.Name}}>.TryParse(string? s, IFormatProvider? provider, out {{recordToGenerate.Name}} result)
                {
                    // TODO
                    throw new NotImplementedException();
                }
            }
            """;

        return source;
    }
}
